# main.py
import os
import json
import time
import re
from flask import Flask, request, jsonify
from openai import OpenAI
import httpx

# –£–±–∏—Ä–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏
os.environ.pop("HTTP_PROXY", None)
os.environ.pop("HTTPS_PROXY", None)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–ª–∏–µ–Ω—Ç–æ–≤
client = OpenAI(
    api_key=os.environ.get("OPENAI_API_KEY"),
    http_client=httpx.Client()
)

ASSISTANT_ID = os.environ.get("ASSISTANT_ID")
app = Flask(__name__)

@app.route("/generate", methods=["POST"])
def generate():
    try:
        print("üì• –ó–∞–ø—Ä–æ—Å –Ω–∞ /generate")

        prompt = request.form.get("prompt", "").strip()
        delete_after = request.form.get("delete_after", "true").lower() == "true"

        

        uploaded_files = [file for key, file in request.files.items() if key.startswith("context_file")]

        if not uploaded_files:
            return jsonify({"error": "–§–∞–π–ª—ã context_file[] –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ã"}), 400


        file_ids = []
        
        for i, uploaded_file in enumerate(uploaded_files):
            if uploaded_file.filename == "":
                continue

            temp_path = f"/tmp/{int(time.time())}_{i}_{uploaded_file.filename}"
            uploaded_file.save(temp_path)

            with open(temp_path, "rb") as f:
                file_response = client.files.create(file=f, purpose="assistants")

            file_ids.append(file_response.id)
            print(f"üìé –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω: {file_response.id}")
            os.remove(temp_path)

        if not file_ids:
            return jsonify({"error": "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∏ –æ–¥–∏–Ω —Ñ–∞–π–ª"}), 500
       

        # –°–æ–∑–¥–∞–µ–º thread
        thread = client.beta.threads.create()
        print(f"üßµ Thread —Å–æ–∑–¥–∞–Ω: {thread.id}")

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å prompt –∏ –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω–Ω—ã–º —Ñ–∞–π–ª–æ–º
        client.beta.threads.messages.create(
            thread_id=thread.id,
            role="user",
            content=prompt,
            
            attachments=[
                {"file_id": fid, "tools": [{"type": "file_search"}]} for fid in file_ids
            ]    
        )

        # –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ (–±–µ–∑ file_ids!)
        run = client.beta.threads.runs.create(
            thread_id=thread.id,
            assistant_id=ASSISTANT_ID,
            extra_headers={"OpenAI-Beta": "assistants=v2"}
        )    
        

        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        while True:
            run_status = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
            if run_status.status == "completed":
                break
            elif run_status.status == "failed":
                return jsonify({"error": "–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –Ω–µ —Å–ø—Ä–∞–≤–∏–ª—Å—è"}), 500
            time.sleep(1)

        # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        messages = client.beta.threads.messages.list(thread_id=thread.id)
        content = ""
        for msg in messages.data:
            for item in msg.content:
                if hasattr(item, "text") and hasattr(item.text, "value"):
                    content += item.text.value.strip() + "\n"

        print("üì¶ –û—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Ä–∞–∑–±–æ—Ä")

        def extract_block(tag, text):
            match = re.search(rf"==={tag}===\s*(.+?)(?=(?:===|$))", text, re.DOTALL)
            return match.group(1).strip() if match else ""

        result = {
            "element_name": extract_block("ELEMENT_NAME", content),
            "meta_title": extract_block("META_TITLE", content),
            "meta_keywords": extract_block("META_KEYWORDS", content),
            "meta_description": extract_block("META_DESCRIPTION", content),
            "article": extract_block("ARTICLE", content) or content.strip()
        }

        # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª
        if delete_after:
            for fid in file_ids:
                try:
                    client.files.delete(fid)
                    print(f"üßπ –§–∞–π–ª {fid} —É–¥–∞–ª—ë–Ω")
                except Exception as e:
                    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {fid}: {e}")

        return jsonify(result)

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ generate(): {e}")
        return jsonify({"error": "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞", "details": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=10000)
